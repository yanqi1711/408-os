# 进程管理

## 进程与线程
### 进程的概念与特征
进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位
```mermaid
flowchart LR
  A[进程组成]
  B[PCB]
  C[进程描述信息]
  D[进程控制和管理信息]
  E[资源分配清单]
  F[处理机相关信息]
  G[程序段]
  H[程序的代码（指令序列）]
  I[数据段]
  J[运行过程中产生的各种数据（如程序中定义的各种变量）]
  A --> B
  A --> G
  A --> I
  B --> C
  B --> D
  B --> E
  B --> F
  G --> H
  I --> J
```
PCB给操作系统用的<br>
程序段、数据段给进程自己用的<br>

特征: 动态性、并发性、独立性、异步性、结构性<br>
动态性是最基础的特性<br>

### 进程的状态与转换

```mermaid
flowchart LR
  A[三种基本状态]
  B[运行态]
  C[占有CPU，并在CPU上运行]
  D[就绪态]
  E[已经具备运行条件，但是由于没有空闲CPU，而暂时不能运行]
  F[阻塞态]
  H[因等待某一事件而暂时不能运行]
  I[另外两种状态]
  J[创建态]
  K[进程正在被创建，操作系统为进程分配资源、初始化PCB]
  L[终止态]
  M[进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB]
  A --> B
  A --> D
  A --> F
  B --> C
  D --> E
  F --> H
  I --> J
  I --> L
  J --> K
  J --> M
```
进程PCB中会有一个`变量state`来表示进程当前状态

进程的转换:
<img src="./img/进程三种状态的转换.png" max-width="80%"/>

进程的组织（大多是链式的）:
- 链接方式
  - 按照进程状态将PCB分为多个队列
  - 操作系统持有指向各个队列的指针
- 索引方式
  - 根据进程状态的不同，建立几张索引表
  - 操作系统持有指向各个索引表的指针

### 进程控制
进程的创建、终止、阻塞、唤醒的过程

#### 创建
```mermaid
flowchart LR
  A[创建原语]
  X[申请空白PCB]
  B[为新进程分配所需资源]
  C[初始化PCB]
  D[将PCB插入就绪队列]
  A --> X
  A --> B
  A --> C
  A --> D

  E[引起进程创建的事件]
  F[用户登陆]
  G[分时系统中，用户登录成功，系统会建立为其建立一个新的进程]
  H[作业调度]
  I[多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程]
  J[提供服务]
  K[用户向操作系统提出某些请求时，会新建一个进程处理该请求]
  L[应用请求]
  M[由用户进程主动请求创建一个子进程]
  E --> F
  E --> H
  E --> J
  E --> L
  F --> G
  H --> I
  J --> K
  L --> M
```

#### 终止
```mermaid
flowchart LR
  A[撤销原语]
  B[从PCB集合中找到终止进程的PCB]
  C[若进程正在运行，立即剥夺CPU，将CPU分配给其他进程]
  D[终止其所有子进程]
  E[将该进程拥有的所有资源归还给父进程或操作系统]
  F[删除PCB]
  A --> B
  A --> C
  A --> D
  A --> E
  A --> F

  G[引起进程终止的事件]
  H[正常结束（进程自已请求终止）]
  I[异常结束（整数除以0、非法使用特权指令然后被OS强制杀掉）]
  J[外界干预（altf4）]
  G --> H
  G --> I
  G --> J
```

#### 阻塞与唤醒
```mermaid
flowchart LR
  A[阻塞原语（运行态到阻塞态）]
  B[找到要阻塞的进程对应的PCB]
  C[保护进程运行现场，将PCB状态信息设置为“阻塞态“，暂时停止进程运行]
  D[将PCB插入相应事件的等待队列]
  A --> B
  A --> C
  A --> D
  E[引起进程阻塞的事件]
  F[需要等待系统分配某种资源]
  G[需要等待相互合作的其他进程完成工作]
  E --> F
  E --> G

  H[唤醒原语（阻塞态到就绪态）]
  I[在事件等待队列中找到PCB]
  J[将PCB从等待队列移除，设置进程为就绪态]
  K[将PCB插入就绪队列，等待被调度]
  H --> I
  H --> J
  H --> K
  L[引起进程唤醒的事件]
  M[等待的事件发生（因何事阻塞，就由何事唤醒）]
  L --> M
```

#### 切换
```mermaid
flowchart LR
  A[切换原语]
  B[将运行环境信息存入PCB]
  C[PCB移入相应队列]
  D[选择另一个进程执行并更新其PCB]
  E[根据PCB恢复新进程所需的运行环境]
  A --> B
  A --> C
  A --> D
  A --> E

  F[引起进程切换的事件]
  G[当前进程时间片到]
  H[有更高优先级的进程到达]
  I[当前进程主动阻塞]
  J[当前进程终止]
  F --> G
  F --> H
  F --> I
  F --> J
```

无论哪个进程控制原语，要做无非三件事：
1. 更新PCB中的信息
2. 将PCB插入合适的队列
3. 分配/回收资源

进程的控制为什么需要一气呵成？<br>
如果不能一气呵成就有可能导致操作系统中某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作<br>
怎么实现原语的原子性的？<br>
使用关中断和开中断这两个特权指令实现原子性<br>

### 进程通信
进程通信指的是进程间的信息交换
有共享存储、消息传递、管道通信三种通信方法
1. 共享存储
  - 设置一个共享内存区域，并映射到进程的虚拟地址空间
  - 要互斥地访问共享空间（由通信进程自己负责实现互斥）
  - 两种方式：
    - 基于数据结构（低级）
    - 基于存储区的共享（高级）
2. 消息传递
  - 传递结构化的消息（消息头/消息体）
  - 系统提供“发送/接受原语”
  - 两种方式：
    - 直接通信（直接发送消息到接收进程的消息队列里）
    - 间接（信箱）通信方式（消息先发到中间体，即信箱，另一个进程再从信箱里去数据）
3. 管道通信
  - 设置一个特殊的共享文件（管道），其实就是一个内存缓冲区
  - 一个管道只能实现伴双工通信 实现双向同时通信要建立两个管道
  - 各进程要互斥访问管道（由操作系统负责实现互斥）
  - 管道写满时，写进程阻塞。管道读空时，读进程阻塞

王道书中的错误：并不是只有管道数据满时，才能读取数据

### 线程的概念与特点
线程是进程的一部分<br>
传统进程机制中，进程是资源分配、调度的基本单位<br>
引入线程后，线程是`调度的基本单位`，进程是资源分配的基本单位<br>

传统机器只能进程间并发，引入线程后，各线程间也能并发<br>

传统的进程间并发需要切换进程运行环境，系统开销很大<br>
引入线程后，在同一进程中的线程切换，不需要切换进程运行环境，开销小<br>

线程的属性：
  - 多CPU计算机中，各个线程可占用不同的CPU
  - 每个线程都有一个线程ID，线程控制块（TCB）
  - 线程也有就绪、阻塞、运行三种基本状态
  - 线程几乎不拥有系统资源，同一进程的不同线程间共享进程的资源
  - 同一进程的线程通信无需操作系统干预

### 线程的实现方式和多线程模型
```mermaid
flowchart LR
  A[线程的实现方式]
  B[用户级线程]
  C[内核级线程]
  D[从用户视角能看到的线程，由线程库实现]
  E[从操作系统视角看到的线程、由操作系统实现（内核级线程才是处理机分配的单位）]
  A --> B
  A --> C
  B --> D
  C --> E

  F[多线程模型]
  G[一对一模型]
  H[一个用户级线程映射到一个内核级线程]
  I[优各个线程可分配到多核处理机并行执行，并发度高]
  J[缺：线程管理都需要操作系统支持，开销大]
  K[多对一模型]
  L[多个用户级线程映射到一个内核级线程]
  M[优：线程管理开销小效率高]
  N[缺：一个线程阻塞会导致整个进程都被阻塞 （并发度低）]
  O[多对多模型]
  P[n个用户级线程映射到m个内核级线程（n≥m）]
  Q[集二者之所长]
  F --> G
  F --> K
  F --> O
  G --> H
  G --> I
  G --> J
  K --> L
  K --> M
  K --> N
  O --> P
  O --> Q
```

### 线程的状态与转换
TCB（线程控制块）大概有如下信息：
  - 线程标识符（TID，与PID类似）
  - 程序计数器PC（线程目前运行到哪）
  - 其他寄存器（线程运行的中间结果）
  - 堆栈指针（保存函数调用信息、局部变量等）
  - 线程运行状态（就绪、运行、阻塞）
  - 优先级（线程调度、资源分配的参考）
线程的组织就是使各种TCB根据不同系统来分门别类的组织起来
线程的控制就是各种状态之间的转换
<img src="./img/线程的状态与转换.png" max-width="80%"/>

---

## 处理机调度
