# 进程与线程

## 进程与线程
### 进程的概念与特征
进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位
```mermaid
flowchart LR
  A[进程组成]
  B[PCB]
  C[进程描述信息]
  D[进程控制和管理信息]
  E[资源分配清单]
  F[处理机相关信息]
  G[程序段]
  H[程序的代码（指令序列）]
  I[数据段]
  J[运行过程中产生的各种数据（如程序中定义的各种变量）]
  A --> B
  A --> G
  A --> I
  B --> C
  B --> D
  B --> E
  B --> F
  G --> H
  I --> J
```
PCB给操作系统用的<br>
程序段、数据段给进程自己用的

特征: 动态性、并发性、独立性、异步性、结构性<br>
动态性是最基础的特性

### 进程的状态与转换

```mermaid
flowchart LR
  A[三种基本状态]
  B[运行态]
  C[占有CPU，并在CPU上运行]
  D[就绪态]
  E[已经具备运行条件，但是由于没有空闲CPU，而暂时不能运行]
  F[阻塞态]
  H[因等待某一事件而暂时不能运行]
  I[另外两种状态]
  J[创建态]
  K[进程正在被创建，操作系统为进程分配资源、初始化PCB]
  L[终止态]
  M[进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB]
  A --> B
  A --> D
  A --> F
  B --> C
  D --> E
  F --> H
  I --> J
  I --> L
  J --> K
  J --> M
```
进程PCB中会有一个`变量state`来表示进程当前状态

进程的转换:
<img src="./img/进程三种状态的转换.png" max-width="80%"/>

进程的组织（大多是链式的）:
- 链接方式
  - 按照进程状态将PCB分为多个队列
  - 操作系统持有指向各个队列的指针
- 索引方式
  - 根据进程状态的不同，建立几张索引表
  - 操作系统持有指向各个索引表的指针

### 进程控制
进程的创建、终止、阻塞、唤醒的过程

#### 创建
```mermaid
flowchart LR
  A[创建原语]
  X[申请空白PCB]
  B[为新进程分配所需资源]
  C[初始化PCB]
  D[将PCB插入就绪队列]
  A --> X
  A --> B
  A --> C
  A --> D

  E[引起进程创建的事件]
  F[用户登陆]
  G[分时系统中，用户登录成功，系统会建立为其建立一个新的进程]
  H[作业调度]
  I[多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程]
  J[提供服务]
  K[用户向操作系统提出某些请求时，会新建一个进程处理该请求]
  L[应用请求]
  M[由用户进程主动请求创建一个子进程]
  E --> F
  E --> H
  E --> J
  E --> L
  F --> G
  H --> I
  J --> K
  L --> M
```

#### 终止
```mermaid
flowchart LR
  A[撤销原语]
  B[从PCB集合中找到终止进程的PCB]
  C[若进程正在运行，立即剥夺CPU，将CPU分配给其他进程]
  D[终止其所有子进程]
  E[将该进程拥有的所有资源归还给父进程或操作系统]
  F[删除PCB]
  A --> B
  A --> C
  A --> D
  A --> E
  A --> F

  G[引起进程终止的事件]
  H[正常结束（进程自已请求终止）]
  I[异常结束（整数除以0、非法使用特权指令然后被OS强制杀掉）]
  J[外界干预（altf4）]
  G --> H
  G --> I
  G --> J
```

#### 阻塞与唤醒
```mermaid
flowchart LR
  A[阻塞原语（运行态到阻塞态）]
  B[找到要阻塞的进程对应的PCB]
  C[保护进程运行现场，将PCB状态信息设置为“阻塞态“，暂时停止进程运行]
  D[将PCB插入相应事件的等待队列]
  A --> B
  A --> C
  A --> D
  E[引起进程阻塞的事件]
  F[需要等待系统分配某种资源]
  G[需要等待相互合作的其他进程完成工作]
  E --> F
  E --> G

  H[唤醒原语（阻塞态到就绪态）]
  I[在事件等待队列中找到PCB]
  J[将PCB从等待队列移除，设置进程为就绪态]
  K[将PCB插入就绪队列，等待被调度]
  H --> I
  H --> J
  H --> K
  L[引起进程唤醒的事件]
  M[等待的事件发生（因何事阻塞，就由何事唤醒）]
  L --> M
```

#### 切换
```mermaid
flowchart LR
  A[切换原语]
  B[将运行环境信息存入PCB]
  C[PCB移入相应队列]
  D[选择另一个进程执行并更新其PCB]
  E[根据PCB恢复新进程所需的运行环境]
  A --> B
  A --> C
  A --> D
  A --> E
  F[引起进程切换的事件]
  G[当前进程时间片到]
  H[有更高优先级的进程到达]
  I[当前进程主动阻塞]
  J[当前进程终止]
  F --> G
  F --> H
  F --> I
  F --> J
```

进程的控制为什么需要一气呵成？
如果不能一气呵成就有可能导致操作系统中某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作
怎么实现原语的原子性的？
使用关中断和开中断这两个特权指令实现原子性
